深入理解EVM


1.深入理解EVM操作码，让你写出更好的智能合约
	 

2.深入Solidity数据存储位置
	 

3.深入Solidity数据存储位置 - 存储
	 

4.深入Solidity数据存储位置 - 内存
	 

5.深入了解Solidity数据位置 - Calldata


6.逆向 EVM - 解析原始Calldata数据


	7.通过逆向和调试深入EVM #1 - 理解汇编


	8.通过逆向和调试理解EVM #2 ：部署智能合约


	9.通过逆向和调试理解EVM #3 ：存储布局如何工作？


	10.通过逆向和调试理解EVM #4：结束/中止执行的5种指令


	11.通过逆向和调试深入EVM #5 - EVM如何处理 if/else/for/functions


	12.通过逆向和调试深入EVM #6 - 完整的智能合约布局


	13.通过逆向和调试深入EVM #7 - 与其他智能合约的交互


14.从EVM 角度看合约创建与部署


15.解构Solidity合约 #1 - 字节码


16.解构 Solidity 合约 #2 - 函数选择器


17.解构 Solidity 合约 #3：函数包装器


18.解构 Solidity 合约 #4: 函数体




# 计算 mapping 中 key的值 

	contract Test{

		mapping(address => uint ) balances;

		function modify() external{
			balances[0x0Dd01A495A499e642a0B7d45CCa54522034fBa2C] = 15;
			balances[0xD8fA8F87129c654a6Dd7F34EEDAf58379E176eb1] = 55;
		}
	}
	
	计算 slot 中key的值  
	
	mapping 的value位于keccak256（key+p），p代表该元素的key的位置
	这个合约 p=0   key就是modify里面的 key  
	
	走 https://emn178.github.io/online-tools/keccak_256.html 
	input  = 0000000000000000000000000Dd01A495A499e642a0B7d45CCa54522034fBa2C0000000000000000000000000000000000000000000000000000000000000000  
	output = 4c5c43199541b94240e734620a0bcf015bf6a8bd38bc0454493647a1232fa77c
	
	input  = 000000000000000000000000D8fA8F87129c654a6Dd7F34EEDAf58379E176eb10000000000000000000000000000000000000000000000000000000000000000
	output = 7d0cc65004514e04bd33b05a78f8fcbe8a385dae7119c3f8723733fd5b491918
	
	{
	"0xc88573d40d4e217348dbf62d0f559aad153ed4561f6c65518a330621710d4027": {
		"key": "0x4c5c43199541b94240e734620a0bcf015bf6a8bd38bc0454493647a1232fa77c",
		"value": "0x000000000000000000000000000000000000000000000000000000000000000f"
	},
	"0x2ad85662c2bbd4685c067cf6f47391785c56f8f914d61e72adff8a8cb09e32b4": {
		"key": "0x7d0cc65004514e04bd33b05a78f8fcbe8a385dae7119c3f8723733fd5b491918",
		"value": "0x0000000000000000000000000000000000000000000000000000000000000037"
	}
