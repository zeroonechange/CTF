## Ethernaut



Good Samaritan
DoubleEntryPoint
Motorbike
Puzzle Wallet
Dex Two
Dex
Shop
Denial



```
20.  Alien Codex  
```

```
19.  MagicNumber  
```

```
18.  Recovery  
```

```
17.  Preservation  
```

```
16.  Naught Coin  
```

```
15.  Gatekeeper Two 
```

```
14.  Gatekeeper One     俩个问题   1.位运算-高位转低位   2.gas debugging调试 
问题1: 
	uint32(uint64(_gateKey)) == uint16(uint64(_gateKey))
	uint32(uint64(_gateKey)) != uint64(_gateKey)
	uint32(uint64(_gateKey)) == uint16(uint160(tx.origin))
		8位 = 一个字节 ＝2个16进制字符 = oxFF =ox 11111111   
		2进制 8 位  XXXXXXXX  表示 0~255 
		uint32 类型的取值范围是 0 到 2 ** 32-1 = 有4个字节 0xFF FF FF FF 
		uint256    256位  除以8  => 32个字节   一个 slot 就是32个字节  
		address 是 0x0Dd01A495A499e642a0B7d45CCa54522034fBa2C  20个字节  

	转换为一个更小的类型，高位将被截断
	key = 0x xx xx xx xx xx xx xx xx   8个字节  16个符号
	key.slice[32,64] = key.slice[48,64]  也就是说 key.slice[32,48]= 0x 00 00  
	key = 0x xx xx xx xx 00 00 xx xx
	key.slice[32,64] != key.slice[1,64]  也就是说 key.slice[1,32] 不能全为0  得有一个1
	key = 0x xx xx xx xx 00 00 xx xx
	key.slice[32,64] = tx.origin.slice[1,16]   也就是说 key.slice[49, 64] = 0x ff ff 
	key = 0x xx xx xx xx 00 00 ff ff
	按照条件2 前面一半的字节只需要不全为0 即可 
	key = 0x f0 00 00 00 00 00 ff ff
		  0x ff 00 00 00 00 00 ff ff
		  0x 00 f0 00 00 00 00 ff ff  都是可以的  
问题2:   
	如果能debugging就好了  没压力
	debug trace 没了  debugging 也无法访问  之前是ok的  看汇编  找到 GAS 操作  得到剩余的gas  按照下面的操作来 
	gas limit = 100000  left=71393  %  8191  = 5865  
	gas limit =  94135  left=65619  %  8191  = 91
	gas limit =  94044  	
```

```
13.  Privacy     slot 相关知识 
	await web3.eth.getStorageAt(instance, 0);
	await web3.eth.getStorageAt(instance, 1);
	await web3.eth.getStorageAt(instance, 2);
	await web3.eth.getStorageAt(instance, 3);
	await web3.eth.getStorageAt(instance, 4);
	await web3.eth.getStorageAt(instance, 5);    -- 这就是 data[2]存放的区域  
	一共32个字节  拿出前一半  
	0xc607037c447e12c2a7d087136d62dbe6224859c14e90c3dffa60eb0c933694e3 
	await contract.unlock('0xc607037c447e12c2a7d087136d62dbe6');
```

```
12.  Elevator 
	这个 测试网有问题 有时候 call 可以跑  有时候又不行  
	有时候 gas 费高得离谱 75ETH   走接口ok
	像 CoinFlip 普通函数通过call 是可以调用的  试了下有时候不行  玄学
```

```
11.  Re-entrance          ***
	一看就不对劲  应该先减再转账   里面有 0.001 Ether  也就是 1 Finney 
	那么先 存进去 1 Finney  再连着取俩次 把钱搞进来 
	钱不能直接从外部账户  通过合约  转给另一个合约账户吗? 
	这里  call - fallback 
	如果 目标合约函数是普通函数  不涉及 payable 那么 像 CoinFlip 一样  普通的 call 即可
	如果 目标合约函数是payable函数  那么 目标合约必须有 fallback 函数  不然call 带了 calldata  是不会去跑 receive 的 
```

```
10.  King               ***
	打破这一个循环 合约接受以太  金额比当前prize大  转账给旧king  更新得到新king 和 新prize
	让king不能接受转账即可  在fallback 中直接 revert  
	看king  await web3.eth.getStorageAt(instance, 0);
	看prize  await web3.eth.getStorageAt(instance, 2);   == 1 Finney  
	很奇怪的是  目前只在构造函数中跑起来过  普通函数去 attack 走不通  代码和构造函数是一样的
	    应该是 构造函数中跑  那么 fallback 中的revert 不会起效果    构造函数 和 普通函数的区别  精巧 
```

```
9.   Vault          slot的原理 
	await web3.eth.getStorageAt(instance, 1);
	await contract.unlock('0x412076657279207374726f6e67207365637265742070617373776f7264203a29');
```

```
8.  Force    销毁合约 可以把本合约的以太发送给任意一个合约  不需要里面带 fallback 或  receive 方法  Holy shit bro
	一般就通过 call 去转账  里面得有  fallback 或  receive 函数  这是个空合约  里面代码啥都没有
	创建一个攻击合约  触发自毁程序 将剩余以太发给目标合约
	合约代码从区块链上移除的唯一方式是合约在合约地址上的执行自毁操作 selfdestruct
	合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。
	移除一个合约听上去不错，但其实有潜在的危险，如果有人发送以太币到移除的合约，这些以太币将永远丢失
```

```
7.  Delegate      通过delegatecall去触发逻辑合约
	await contract.sendTransaction({data: '0xdd365b8b'});
```

```
6. Token   溢出攻击   uint 就是  uint256   20-21 溢出 = type(uint).max-1
```

```
5. Telephone    了解下  调用者  tx.origin  
```

```
4. CoinFlip  -  这里 有几个坑   
第一个就是 用 address.call 去调用  之前不知道为啥一直跑不起来   这个俩个用处  1.当前推荐发送以太给另一个合约  2.直接调用其他合约的函数 
第二个就是 remix 提醒 gas limit  明明是ok的    钱包 metamask 用本地  跑的没反应  这里感觉最好用 hardhat  不断打log 才知道啥情况 
第三个就是   fallback 和  receive 函数里面不要写耗时的操作  不然gas 不够  抛异常  error - out of gas  
    function attackByInterface(address _addr) public {
        bool side = getFlip();
        ICoinFlip(_addr).flip(side);
    }

    // call 只推荐用于发送以太-在有fallback函数在情况下    其他情况下不推荐-也就是普通函数不推荐使用  但是也能用 
    function attackByCall(address _addr) public {
        bool side = getFlip();
       (bool sent, bytes memory data) = _addr.call(abi.encodeWithSignature("flip(bool)", side));
       require(sent, "Failed to call function");   
    }
```

```
3. Fallout - 这里构造函数不对   SWC-118   剩下非常简单了 
```

```
2. Fallback - 这里难在调用 
contribute() 是个 payable 函数  直接控制台 调用  在括号加 以太值
    await contract.contribute({value:1})
    await contract.sendTransaction({value:1})    触发了 receive()   Fallback() 
    await contract.owner() === player
    await contract.withdraw()
```

```
1.Hello Ethernaut - 做准备工作  领取测试以太  
    await getBalance(player)
    help()
    await contract.abi
```


这里主要借鉴 
1. https://solidity-by-example.org/
2. https://ethernaut.openzeppelin.com/ 